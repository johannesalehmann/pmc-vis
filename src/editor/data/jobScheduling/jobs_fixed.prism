
const int num_jobs = 3;
const int num_machine = 3;
const int max_load = 4;

const int machine1_power_1 = 1;
const int machine1_power_2 = 2;
const int machine1_power_3 = 2;
const int machine1_power_4 = 4;

const int machine2_power_1 = 1;
const int machine2_power_2 = 3;
const int machine2_power_3 = 2;
const int machine2_power_4 = 4;

const int machine3_power_1 = 1;
const int machine3_power_2 = 3;
const int machine3_power_3 = 4;
const int machine3_power_4 = 4;

const int max_charge = 2;

init
  ( 
    (load1 = 0) & (load2 = 0) & (load3 = 0) & 
    !used1 & !used2 & !used3 & (charge = 2) &
    (phase = 0) & (time = 0) & (
      ((power1 = 1) & (power2 = 1) & (power3 = 1)) | 
      ((power1 = 2) & (power2 = 2) & (power3 = 2)) | 
      ((power1 = 2) & (power2 = 3) & (power3 = 3)) | 
      ((power1 = 2) & (power2 = 3) & (power3 = 4)) | 
      ((power1 = 2) & (power2 = 2) & (power3 = 4)) | 
      ((power1 = 3) & (power2 = 4) & (power3 = 4)) | 
      ((power1 = 4) & (power2 = 4) & (power3 = 4))
  )) 
endinit

// Forces the model to assign jobs to machines if still possible
global block_end: bool;  

global battery_enabled: bool;

module job1
  load1: [0..max_load];

  [run_1_1] load1 <= power1 -> (load1'=0);
  [run_1_1] battery_enabled & (load1 > power1) & (load1 <= (power1 + charge)) -> (load1'=0);

  [run_2_1] load1 <= power2 -> (load1'=0);
  [run_2_1] battery_enabled & (load1 > power2) & (load1 <= (power2 + charge)) -> (load1'=0);

  [run_3_1] load1 <= power3 -> (load1'=0);
  [run_3_1] battery_enabled & (load1 > power3) & (load1 <= (power3 + charge)) -> (load1'=0);
  
  [generate_1] (load1=0) -> (1/4) : (load1'= 1) + (1/4) : (load1'= 2) + (1/4) : (load1'= 3) + (1/4) : (load1'= 4);
  [reset] true ->  (load1'=0);
endmodule

module job2 = job1 [
	load1 = load2, generate_1 = generate_2,
  run_1_1 = run_1_2, run_2_1 = run_2_2, run_3_1 = run_3_2
] endmodule

module job3 = job1 [
	load1 = load3, generate_1 = generate_3,
  run_1_1 = run_1_3, run_2_1 = run_2_3, run_3_1 = run_3_3
] endmodule

module machine1
  power1: [1..max_load];
  used1: bool;

  [run_1_1] !used1 -> (used1'=true);
  [run_1_2] !used1 -> (used1'=true);
  [run_1_3] !used1 -> (used1'=true);

  [reset] true -> (used1'=false);
endmodule

module machine2 = machine1 [
	power1 = power2, used1 = used2,
  run_1_1 = run_2_1, run_1_2 = run_2_2, run_1_3 = run_2_3
] endmodule


module machine3 = machine1 [
	power1 = power3, used1 = used3,
  run_1_1 = run_3_1, run_1_2 = run_3_2, run_1_3 = run_3_3
] endmodule

module battery
  charge: [0..max_charge];

  [run_1_1] battery_enabled & (load1 > power1) & (load1 <= (power1 + charge)) -> (charge'=max((charge-(load1-power1)), 0));
  [run_1_1] battery_enabled & ((load1 <= power1) | (load1 > (power1 + charge))) -> true;
  [run_1_1] !battery_enabled -> true;

  [run_1_2] battery_enabled & (load2 > power1) & (load2 <= (power1 + charge)) -> (charge'=max((charge-(load2-power1)), 0));
  [run_1_2] battery_enabled & ((load2 <= power1) | (load2 > (power1 + charge))) -> true;
  [run_1_2] !battery_enabled -> true;

  [run_1_3] battery_enabled & (load3 > power1) & (load3 <= (power1 + charge)) -> (charge'=max((charge-(load3-power1)), 0));
  [run_1_3] battery_enabled & ((load3 <= power1) | (load3 > (power1 + charge))) -> true;
  [run_1_3] !battery_enabled -> true;

  [run_2_1] battery_enabled & (load1 > power2) & (load1 <= (power2 + charge)) -> (charge'=max((charge-(load1-power2)), 0));
  [run_2_1] battery_enabled & ((load1 <= power2) | (load1 > (power2 + charge))) -> true;
  [run_2_1] !battery_enabled -> true;

  [run_2_2] battery_enabled & (load2 > power2) & (load2 <= (power2 + charge)) -> (charge'=max((charge-(load2-power2)), 0));
  [run_2_2] battery_enabled & ((load2 <= power2) | (load2 > (power2 + charge))) -> true;
  [run_2_2] !battery_enabled -> true;

  [run_2_3] battery_enabled & (load3 > power2) & (load3 <= (power2 + charge)) -> (charge'=max((charge-(load3-power2)), 0));
  [run_2_3] battery_enabled & ((load3 <= power2) | (load3 > (power2 + charge))) -> true;
  [run_2_3] !battery_enabled -> true;
  
  [run_3_1] battery_enabled & (load1 > power3) & (load1 <= (power3 + charge)) -> (charge'=max((charge-(load1-power3)), 0));
  [run_3_1] battery_enabled & ((load1 <= power3) | (load1 > (power3 + charge))) -> true;
  [run_3_1] !battery_enabled -> true;

  [run_3_2] battery_enabled & (load2 > power3) & (load2 <= (power3 + charge)) -> (charge'=max((charge-(load2-power3)), 0));
  [run_3_2] battery_enabled & ((load2 <= power3) | (load2 > (power3 + charge))) -> true;
  [run_3_2] !battery_enabled -> true;

  [run_3_3] battery_enabled & (load3 > power3) & (load3 <= (power3 + charge)) -> (charge'=max((charge-(load3-power3)), 0));
  [run_3_3] battery_enabled & ((load3 <= power3) | (load3 > (power3 + charge))) -> true;
  [run_3_3] !battery_enabled -> true;


endmodule

formula open_jobs = ((load1 > 0)? 1 : 0) + ((load2 > 0)? 1 : 0) + ((load3 > 0)? 1 : 0);
formula open_load = load1 + load2 + load3;

formula job_possible_1 = (load1 > 0) & (((!used1 & (load1 <= power1))| (!used2 & (load1 <= power2)) | (!used3 & (load1 <= power3)) ) | (battery_enabled & job_possible_charged_1));
formula job_possible_2 = (load2 > 0) & (((!used1 & (load2 <= power1))| (!used2 & (load2 <= power2)) | (!used3 & (load2 <= power3)) ) | (battery_enabled & job_possible_charged_2));
formula job_possible_3 = (load3 > 0) & (((!used1 & (load3 <= power1))| (!used2 & (load3 <= power2)) | (!used3 & (load3 <= power3)) ) | (battery_enabled & job_possible_charged_3));

formula job_possible_charged_1 = ((!used1 & (load1 <= power1 + charge))| (!used2 & (load1 <= power2 + charge))| (!used3 & (load1 <= power3 + charge)));
formula job_possible_charged_2 = ((!used1 & (load2 <= power1 + charge))| (!used2 & (load2 <= power2 + charge))| (!used3 & (load2 <= power3 + charge)));
formula job_possible_charged_3 = ((!used1 & (load3 <= power1 + charge))| (!used2 & (load3 <= power2 + charge))| (!used3 & (load3 <= power3 + charge)));

formula jobs_possible = job_possible_1 | job_possible_2 | job_possible_3;

module timer
  phase: [0..4];
  time: [0..3];

  [generate_1] (phase=0) -> (phase'=1);
  [generate_2] (phase=1) -> (phase'=2);
  [generate_3] (phase=2) -> (phase'=3);

  [run_1_1] (phase=3) -> true;
  [run_1_2] (phase=3) -> true;
  [run_1_3] (phase=3) -> true;

  [run_2_1] (phase=3) -> true;
  [run_2_2] (phase=3) -> true;
  [run_2_3] (phase=3) -> true;

  [run_3_1] (phase=3) -> true;
  [run_3_2] (phase=3) -> true;
  [run_3_3] (phase=3) -> true;

  [end]   (phase=3) & !(block_end & jobs_possible) -> (phase'=4);
  [reset] (phase=4) & (time<3) -> (phase'=0) & (time'=time+1);
  [over] (phase=4) & (time=3) -> true;
endmodule

label "failed" = (phase=4) & (open_jobs>0);
label "success" = (phase=4) & (open_jobs=0);
label "no_violations" = (phase!=4) | (open_jobs=0);
label "end" = (phase=4) & (time=3);

rewards "violations"
  [end] true: open_jobs;
endrewards

rewards "loads"
  [end] true: open_load;
endrewards

rewards "cost"
  [run_1_1] (!battery_enabled) : power1;
  [run_1_2] (!battery_enabled) : power1;
  [run_1_3] (!battery_enabled) : power1;

  [run_2_1] (!battery_enabled) : power2;
  [run_2_2] (!battery_enabled) : power2;
  [run_2_3] (!battery_enabled) : power2;

  [run_3_1] (!battery_enabled) : power3;
  [run_3_2] (!battery_enabled) : power3;
  [run_3_3] (!battery_enabled) : power3;

  [run_1_1] (battery_enabled) : 2*power1;
  [run_1_2] (battery_enabled) : 2*power1;
  [run_1_3] (battery_enabled) : 2*power1;

  [run_2_1] (battery_enabled) : 2*power2;
  [run_2_2] (battery_enabled) : 2*power2;
  [run_2_3] (battery_enabled) : 2*power2;

  [run_3_1] (battery_enabled) : 2*power3;
  [run_3_2] (battery_enabled) : 2*power3;
  [run_3_3] (battery_enabled) : 2*power3;
endrewards


